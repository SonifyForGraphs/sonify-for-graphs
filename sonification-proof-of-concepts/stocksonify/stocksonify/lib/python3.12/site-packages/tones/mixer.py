import math
import wave

import tones
from tones.tone import Tone, Samples

class Track(object):
    """
    Represents a single track in a Mixer
    """

    def __init__(self, wavetype=tones.SINE_WAVE, attack=None, decay=None,
            vibrato_frequency=None, vibrato_variance=15.0):
        """
        Initializes a Track

        :param int wavetype: initial wavetype setting for this track
        :param float attack: initial tone attack for this track, to applied to \
            each set of samples generated by 'append_samples'
        :param float decay: initial tone decay for this track, to applied to \
            each set of samples generated by 'append_samples'
        :param float vibrato_frequency: initial vibrato frequency for this track
        :param float vibrato_variance: initial vibrato variance for this track
        """

        self._attack = attack
        self._decay = decay
        self._vibrato_frequency = vibrato_frequency
        self._vibrato_variance = vibrato_variance
        self._phase = 0.0
        self._vphase = 0.0
        self._samples = Samples()
        self._wavetype = wavetype
        self._weighting = None

    def append_samples(self, samples):
        """
        Append samples to this track. Samples should be in the range -1.0 to 1.0

        :param [float] samples: samples to append
        """

        self._samples.extend(samples)

class Mixer(object):
    """
    Represents multiple tracks that can be summed together into a single
    list of samples
    """

    _notes = {
        "c": 261.625565301,
        "c#": 277.182630977,
        "db": 277.182630977,
        "d": 293.664767918,
        "d#": 311.126983723,
        "eb": 311.126983723,
        "e": 329.627556913,
        "e#": 349.228231433,
        "f": 349.228231433,
        "f#": 369.994422712,
        "gb": 369.994422712,
        "g": 391.995435982,
        "g#": 415.30469758,
        "ab": 415.30469758,
        "a": 440.0,
        "a#": 466.163761518,
        "bb": 466.163761518,
        "b": 493.883301256
    }

    def __init__(self, sample_rate=44100, amplitude=0.5):
        """
        Initializes a Mixer

        :param int sample_rate: sampling rate in Hz
        :param float amplitude: master amplitude in the range 0.0 to 1.0
        """

        self._rate = sample_rate
        self._amp = amplitude
        self._tracks = {}

    def _get_track(self, trackname):
        try:
            ret = self._tracks[trackname]
        except KeyError:
            raise ValueError("No such track '%s'" % trackname)

        return ret

    def _get_note(self, note, octave):
        try:
            freq = self._notes[note.lower()]
        except KeyError:
            raise ValueError("invalid note: %s" % note)

        if octave < 4:
            freq /= math.pow(2, (4 - octave))
        elif octave > 4:
            freq *= math.pow(2, (octave - 4))

        return freq

    def _silence(self, samples):
        return Samples([0.0] * int(samples))

    def create_track(self, trackname, *args, **kwargs):
        """
        Creates a Tone track

        :param trackname: unique identifier for track. Can be any hashable type.
        :param args: arguments for Track constructor
        :param kwargs: keyword arguments for Track constructor
        """

        self._tracks[trackname] = Track(*args, **kwargs)

    def set_attack(self, trackname, attack):
        """
        Set the tone attack for a track. This attack will be applied to
        all tones added to this track.

        :param trackname: track identifier
        :param float attack: attack time in seconds
        """

        track = self._get_track(trackname)
        track._attack = attack

    def get_attack(self, trackname):
        """
        Get the tone attack for a track

        :param trackname: track identifier
        :return: tone attack
        :rtype: float
        """

        track = self._get_track(trackname)
        return track._attack

    def set_decay(self, trackname, decay):
        """
        Set tone decay for a track. This decay will be applied to all tones
        added to this track

        :param trackname: track identifier
        :param float decay: decay time in seconds
        """

        track = self._get_track(trackname)
        track._decay = decay

    def get_decay(self, trackname):
        """
        Get the tone decay for a track

        :param trackname: track identifier
        :return: tone decay
        :rtype: float
        """

        track = self._get_track(trackname)
        return track._decay

    def set_vibrato_frequency(self, trackname, frequency):
        """
        Set vibrato frequency for a track. This vibrato frequency will be
        applied to all tones added to this track

        :param trackname: track identifier
        :param float frequency: vibrato frequency in Hz
        """

        track = self._get_track(trackname)
        track._vibrato_frequency = frequency

    def get_vibrato_frequency(self, trackname):
        """
        Get the vibrato frequency for a track

        :param trackname: track identifier
        :return: vibrato frequency in Hz
        :rtype: float
        """

        track = self._get_track(trackname)
        return track._vibrato_frequency

    def set_vibrato_variance(self, trackname, variance):
        """
        Set vibrato variance for a track. The variance represents the full range
        that the highest and lowest points of the vibrato will reach, in Hz; for
        example, a tone at 440Hz with a vibrato variance of 20hz would
        oscillate between 450Hz and 430Hz. This vibrato variance will be
        applied to all tones added to this track

        :param trackname: track identifier
        :param float variance: vibrato variance in Hz
        """

        track = self._get_track(trackname)
        track._vibrato_variance = variance

    def get_vibrato_variance(self, trackname):
        """
        Get the vibrato variance for a track

        :param trackname: track identifier
        :return: vibrato variance in Hz
        :rtype: float
        """

        track = self._get_track(trackname)
        return track._vibrato_variance

    def add_samples(self, trackname, samples):
        """
        Adds samples to a track

        :param trackname: track identifier, track to add samples to
        :param [float] samples: samples to add
        """

        track = self._get_track(trackname)
        track.append_samples(samples)

    def add_tone(self, trackname, frequency=440.0, duration=1.0,
            endfrequency=None, attack=None, decay=None, amplitude=1.0,
            vibrato_frequency=None, vibrato_variance=None):
        """
        Create a tone and add the samples to a track

        :param trackname: track identifier, track to add tone to
        :param float frequency: tone frequency
        :param float duration: tone duration in seconds
        :param float attack: tone attack in seconds. Overrides the track's \
            attack setting
        :param float decay: tone decay in seconds. Overrides the track's \
            decay setting
        :param float vibrato_frequency: tone vibrato frequency in Hz. Overrides\
            the track's vibrato frequency setting
        :param float vibrato_variance: tone vibrato variance in Hz. Overrides\
            the track's vibrato variance setting
        :param float amplitude: Tone amplitude, where 1.0 is the max. sample \
            value and 0.0 is total silence
        """

        track = self._get_track(trackname)
        tone = Tone(self._rate, amplitude, track._wavetype)
        numsamples = int(duration * self._rate)

        if not attack:
            attack = track._attack
        if not decay:
            decay = track._decay
        if not vibrato_frequency:
            vibrato_frequency = track._vibrato_frequency
        if not vibrato_variance:
            vibrato_variance = track._vibrato_variance

        samples, track._phase, track._vphase = tone.samples(numsamples,
                frequency, endfrequency, attack, decay, track._phase,
                track._vphase, vibrato_frequency, vibrato_variance)

        track.append_samples(samples)

    def add_note(self, trackname, note="a", octave=4, duration=1.0,
            endnote=None, endoctave=None, attack=None, decay=None,
            amplitude=1.0, vibrato_frequency=None, vibrato_variance=None):
        """
        Same as 'add_tone', except the pitch can be specified as a standard
        musical note, e.g. "c#"

        :param trackname: track identifier, track to add tone to
        :param str note: musical note. Must be a single character from a-g \
            (non case-sensitive), followed by an optional sharp ('#') or flat \
            ('b') character
        :param str endnote: If not None, the tone frequency will change \
            between 'note' and 'endnote' in increments of 1ms over \
            all samples
        :param int octave: note octave from 0-8
        :param int endoctave: octave for the note specified by endnote
        :param float duration: tone duration in seconds
        :param float attack: tone attack in seconds. Overrides the track's \
            attack setting
        :param float decay: tone decay in seconds. Overrides the track's \
            decay setting
        :param float vibrato_frequency: tone vibrato frequency in Hz. Overrides\
            the track's vibrato frequency setting
        :param float vibrato_variance: tone vibrato variance in Hz. Overrides\
            the track's vibrato variance setting
        :param float amplitude: Tone amplitude, where 1.0 is the max. sample \
            value and 0.0 is total silence
        """

        endfreq = None

        freq = self._get_note(note, octave)
        if endnote:
            if not endoctave:
                endoctave = octave

            endfreq = self._get_note(endnote, endoctave)

        self.add_tone(trackname, freq, duration, endfreq, attack, decay,
            amplitude, vibrato_frequency, vibrato_variance)

    def add_tones(self, tonelist):
        """
        Create multiple tones and add the samples for each tone in order to a
        track

        :param tonelist: list of tuples, where each tuple contains arguments \
            for a single Mixer.add_tone invocation
        """

        for arglist in tonelist:
            self.add_tone(*arglist)

    def add_notes(self, trackname, notelist):
        """
        Create multiple notes and add the samples for each tone in order to a
        track

        :param trackname: track identifier
        :param notelist: list of tuples, where each tuple contains arguments \
            for a single Mixer.add_note invocation
        """

        for arglist in notelist:
            self.add_note(trackname, *arglist)

    def add_silence(self, trackname, duration=1.0):
        """
        Adds silence to a track

        :param trackname: track identifier, track to add silence to
        :param float duration: silence duration in seconds
        """

        track = self._get_track(trackname)
        track.append_samples(self._silence(duration * self._rate))

    def set_wavetype(self, trackname, wavetype):
        """
        Sets the waveform type for a track

        :param trackname: track identifier, track to set wavetype for
        :param int wavetype: waveform type
        """

        track = self._get_track(trackname)
        track._wavetype = wavetype

    def get_wavetype(self, trackname):
        """
        Get the waveform type for a track

        :param trackname: track identifier
        :return: track waveform type
        :rtype: int
        """

        track = self._get_track(trackname)
        return track._wavetype

    def mix(self):
        """
        Mixes all tracks into a single stream of samples

        :return: mixed samples
        :rtype: Samples
        """

        if len(self._tracks) == 0:
            return Samples([])

        tracks = list(self._tracks.values())
        tracks.sort(key=lambda x: len(x._samples), reverse=True)

        default_div = len(tracks)
        weight = 1.0 / default_div

        ret = self._silence(len(tracks[0]._samples))

        for track in tracks:
            for i in range(len(track._samples)):
                ret[i] += (track._samples[i] * weight) * self._amp

        return ret

    def sample_data(self):
        """
        Mixes all trackes down into a single stream of samples and returns the
        samples as a 16-bit PCM stream packed into a string
        """
        return self.mix().serialize()

    def write_wav(self, filename, sampledata=None):
        """
        Mixes all tracks into a single stream of samples and writes to a
        .wav audio file

        :param str filename: name of file to write
        """

        if sampledata is None:
            sampledata = self.mix().serialize()

        f = wave.open(filename, 'w')

        f.setparams((tones.NUM_CHANNELS, tones.DATA_SIZE, self._rate,
            int(len(sampledata) / 2), "NONE", "Uncompressed"))

        f.writeframes(sampledata)
        f.close()
